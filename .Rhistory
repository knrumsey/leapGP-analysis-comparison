par(mfrow=c(1,2))
plot(x1,
col=colorRampPalette(rev(brewer.pal(11, "RdBu")))(100), interpolate=TRUE)
plot(x2,
col=colorRampPalette(rev(brewer.pal(11, "RdBu")))(100))
range(out[1,])
range(out)
rr
plot(x1,
col=colorRampPalette(rev(brewer.pal(11, "Blues")))(100), interpolate=TRUE)
par(mfrow=c(1,2))
plot(x1,
col=colorRampPalette((brewer.pal(11, "Blues")))(100), interpolate=TRUE)
plot(x2,
col=colorRampPalette((brewer.pal(11, "Blues")))(100))
plot(x1,
col=colorRampPalette((brewer.pal(11, "Blues")))(200), interpolate=TRUE)
plot(x2,
col=colorRampPalette((brewer.pal(11, "Blues")))(100))
?slapGP
hist(abs(1+rt(1000, 3)))
hist(abs(1+rt(1000, 2)))
load("Data/piston_sim_output_N4000.rda")
set.seed(111)
N <- 4000
X <- quack::smartLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
# Get data for prediction
N2 <- 10000
X2 <- quack::smartLHS(N2, 7)
y2 <- apply(X2, 1, piston, scale01=TRUE)
# CAUTION: These simulations can take a really long time for large N
library(stargazer)     # Latex Tables
library(tictoc)        # Timing package
library(RColorBrewer)  # R Colors
library(lhs)           # Design
library(quack)         # leapGP: devtools::github_install("knrumsey/quack")
library(laGP)          # laGP
library(BASS)          # Bayesian MARS
library(BART)          # bart
library(BayesPPR)      # bppr: devtools::github_install("gqcollins/BayesPPR")
library(gplite)        # FITC (inducing point GP)
library(tgp)           # bcart
source("piston.R")     # piston function
source("R/piston.R")     # piston function
N <- 4000
X <- quack::smartLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
# Get data for prediction
N2 <- 10000
X2 <- quack::smartLHS(N2, 7)
y2 <- apply(X2, 1, piston, scale01=TRUE)
tic()
mod_ppr <- bppr(X, y)
toc_ppr <- toc()
tic()
yht_ppr <- cov_ppr <- rep(NA, N2)
for(i in 1:1000){
pred <- predict(mod_ppr, matrix(X2[i,], nrow=1))
pred2 <- pred + rnorm(1000, 0, mod_ppr$sd_resid)
yht_ppr[i] <- mean(pred)
cov_ppr[i] <- (quantile(pred2, 0.025) < y2[i]) & (quantile(pred2, 0.975) > y2[i])
}
toc_ppr2 <- toc()
source('https://raw.githubusercontent.com/katzfuss-group/scaledVecchia/master/vecchia_scaled.R')
install.packages("GpGP")
install.packages("GpGp")
120*10
rmpse(y2, yht_ppr)
# MAKE TABLE
# =============================================
rmspe <- function(y, y2) sqrt(mean((y-y2)^2))
rmpse(y2, yht_ppr)
# MAKE TABLE
# =============================================
rmspe <- function(y, y2) sqrt(mean((y-y2)^2))
rmpse(y2, yht_ppr)
rmspe(y2, yht_ppr)
y2
rmspe(y2[1:1000], yht_ppr[1:1000])
rmspe(y2[1:1000], yht_ppr[1:1000])*60
# MAKE TABLE
# =============================================
rmspe <- function(y, y2) sqrt(mean((y-y2)^2))
my_tab <- matrix(NA, nrow=14, ncol=4)
rownames(my_tab) <- c("BASS", "BART", "FITC", "BCART", "BPPR", "laGP",
"leapGP(M0, 0)",
"leapGP(M0, 0.80)",
"leapGP(M0, 0.90)",
"leapGP(M0, 0.95)",
"leapGP(M0, 0.96)",
"leapGP(M0, 0.97)",
"leapGP(M0, 0.98)",
"leapGP(M0, 0.99)")
colnames(my_tab) <- c("Train (s)", "Pred (s)", "RMSPE", "Coverage")
my_tab[1,] <- c(toc_bass$toc - toc_bass$tic,
toc_bass2$toc - toc_bass$tic,
rmspe(yht_bass, y2),
sum(cov_bass, na.rm=TRUE)/length(cov_bass))
my_tab[2,] <- c(toc_bart$toc - toc_bart$tic,
(toc_bart2$toc - toc_bart2$tic)*N2/1000,
rmspe(yht_bart[1:1000], y2[1:1000]),
sum(cov_bart, na.rm=TRUE)/length(cov_bart[1:1000]))
my_tab[3,] <- c(toc_sgp$toc - toc_sgp$tic,
(toc_sgp2$toc - toc_sgp2$tic)*N2/1000,
rmspe(yht_sgp[1:1000], y2[1:1000]),
sum(cov_sgp[1:1000], na.rm=TRUE)/length(cov_sgp[1:1000]))
my_tab[4,] <- c(toc_tgp$toc - toc_tgp$tic,
toc_tgp2$toc - toc_tgp2$tic,
rmspe(yht_tgp, y2),
sum(cov_tgp, na.rm=TRUE)/length(cov_sgp))
my_tab[5,] <- c(toc_ppr$toc - toc_ppr$tic,
(toc_ppr2$toc - toc_ppr2$tic)*N2/1000,
rmspe(yht_ppr[1:1000], y2[1:1000]),
sum(cov_ppr, na.rm=TRUE)/length(cov_ppr[1:1000]))
my_tab[6,] <- c(0,
toc_la$toc - toc_la$tic,
rmspe(yht_la, y2),
sum(cov_la, na.rm=TRUE)/length(cov_la))
my_tab[7,] <- c(toc_leap$toc - toc_leap$tic,
toc_leap2$toc - toc_leap2$tic,
rmspe(yht_leap, y2),
sum(cov_leap, na.rm=TRUE)/length(cov_leap))
for(i in 1:7){
my_tab[7+i,] <- c(toc_leap$toc - toc_leap$tic,
toc_slap[i],
rmspe(yht_slap[,i], y2),
sum(cov_slap[,i], na.rm=TRUE)/nrow(cov_slap))
}
my_tab[,3] <- my_tab[,3]*60 #RMSPE NOW HAS AN INTERPRETATION FOR UNITS OF MINUTES INSTEAD OF SECONDS
save(my_tab, file=paste0("my_tab_", N, ".rda"))
# SAVE LATEX OUTPUT
# =============================================
sink(file=paste0("table_", N, ".txt"))
tmp = stargazer(my_tab, digits=2)
sink()
#MAKE FIGURES
# =============================================
# RMSPE
png(paste0("Figures/piston_rmspe_", N, ".png"),
width=5, height=5.5, res=300, units="in")
par(mar=c(9,4,2.5,2) + 0.1)
tmp <- my_tab[,3]
ord <- order(tmp)
plot(1:length(tmp), tmp[ord], type='h', xaxt='n', ylab='RMSPE', xlab="", col='white',
xlim=c(.5, length(tmp)+0.5), ylim=c(0, 0.6))
axis(1, 1:length(tmp), rownames(my_tab)[ord], las=2)
eps <- 0.4
bob <- rep("black", 14)
bob[c(7:14, 6)] <- brewer.pal(9, "Blues")
for(i in 1:14){
zz <- tmp[ord[i]]
rect(i-eps, 0, i+eps, zz, border="black", col=adjustcolor(bob[ord[i]], 0.6), lwd=2)
}
dev.off()
# Timing
png(paste0("Figures/piston_timing_", N, ".png"),
width=5, height=5.5, res=300, units="in")
par(mar=c(9,4,2.5,2) + 0.1)
tmp <- my_tab[,2] + my_tab[,1]
ord <- order(my_tab[,2])
plot(1:length(tmp), log10(my_tab[ord,2]), type='p', xaxt='n', ylab='Time (seconds)', xlab="", col='white', xlim=c(.5, length(tmp)+0.5), yaxt='n')
axis(1, 1:length(tmp), rownames(my_tab)[ord], las=2)
eps <- 0.4
bob <- rep("black", 14)
bob[c(7:14, 6)] <- brewer.pal(9, "Blues")
for(i in 1:14){
zz <- log10(my_tab[ord[i], 2])
rect(i-eps, log10(min(my_tab[,2])/1.1), i+eps, zz, border="black", col=adjustcolor(bob[ord[i]], 0.6), lwd=2)
#rect(i-eps, zz, i+eps, log(tmp[ord[i]]), border="black", lwd=2)
}
axis(2, pretty(range(log10(tmp)), n=4), 10^pretty(range(log10(tmp)), n=4))
dev.off()
# RMSPE
png(paste0("Figures/piston_rmspe_", N, ".png"),
width=5, height=5.5, res=300, units="in")
par(mar=c(9,4,2.5,2) + 0.1)
tmp <- my_tab[,3]
ord <- order(tmp)
plot(1:length(tmp), tmp[ord], type='h', xaxt='n', ylab='RMSPE', xlab="", col='white',
xlim=c(.5, length(tmp)+0.5))
axis(1, 1:length(tmp), rownames(my_tab)[ord], las=2)
eps <- 0.4
bob <- rep("black", 14)
bob[c(7:14, 6)] <- brewer.pal(9, "Blues")
for(i in 1:14){
zz <- tmp[ord[i]]
rect(i-eps, 0, i+eps, zz, border="black", col=adjustcolor(bob[ord[i]], 0.6), lwd=2)
}
dev.off()
# Timing
png(paste0("Figures/piston_timing_", N, ".png"),
width=5, height=5.5, res=300, units="in")
par(mar=c(9,4,2.5,2) + 0.1)
tmp <- my_tab[,2] + my_tab[,1]
ord <- order(my_tab[,2])
plot(1:length(tmp), log10(my_tab[ord,2]), type='p', xaxt='n', ylab='Time (seconds)', xlab="", col='white', xlim=c(.5, length(tmp)+0.5), yaxt='n')
axis(1, 1:length(tmp), rownames(my_tab)[ord], las=2)
eps <- 0.4
bob <- rep("black", 14)
bob[c(7:14, 6)] <- brewer.pal(9, "Blues")
for(i in 1:14){
zz <- log10(my_tab[ord[i], 2])
rect(i-eps, log10(min(my_tab[,2])/1.1), i+eps, zz, border="black", col=adjustcolor(bob[ord[i]], 0.6), lwd=2)
#rect(i-eps, zz, i+eps, log(tmp[ord[i]]), border="black", lwd=2)
}
axis(2, pretty(range(log10(tmp)), n=4), 10^pretty(range(log10(tmp)), n=4))
dev.off()
library(quack)
library(lhs)
library(GpGp)
source("R/piston.R")
source('https://raw.githubusercontent.com/katzfuss-group/scaledVecchia/master/vecchia_scaled.R')
# Generate data
set.seed(111)
N <- 4000
X <- quack::smartLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
# Get data for prediction
N2 <- 10000
X2 <- quack::smartLHS(N2, 7)
y2 <- apply(X2, 1, piston, scale01=TRUE)
# Fit scaled Vecchia GP (Katzfuss et al., 2020)
fit_vecc <- fit_scaled(y, X)
install.packages("GPvecchia")
library(GPvecchia)
source('https://raw.githubusercontent.com/katzfuss-group/scaledVecchia/master/vecchia_scaled.R')
library(quack)
library(lhs)
library(GpGp)
library(GPvecchia)
source("R/piston.R")
source('https://raw.githubusercontent.com/katzfuss-group/scaledVecchia/master/vecchia_scaled.R')
# Generate data
set.seed(111)
N <- 4000
X <- quack::smartLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
# Get data for prediction
N2 <- 10000
X2 <- quack::smartLHS(N2, 7)
y2 <- apply(X2, 1, piston, scale01=TRUE)
# Fit scaled Vecchia GP (Katzfuss et al., 2020)
fit_vecc <- fit_scaled(y, X)
library(tictoc)
tic()
fit_vecc <- fit_scaled(y, X)
toc_vecc <- toc()
12.355*10
12.355*100
pred = predictions(fit_vecc, X2[1,])
pred = predictions(fit_vecc, matrix(X2[1,], nrow=1))
2[1,]
X2[1,]
pred = predictions(fit_vecc, (X2[1:10,], nrow=1))
pred = predictions(fit_vecc, (X2[1:10,]))
pred = predictions_sclaed(fit_vecc, (X2[1:10,]))
pred = predictions_scaled(fit_vecc, (X2[1:10,]))
pred = predictions_scaled(fit_vecc, matrix(X2[i,], nrow=1))
matrix(X2[i,], nrow=1)
pred = predictions_scaled(fit_vecc, matrix(X2[i,], nrow=1))
pred = predictions_scaled(fit_vecc, matrix(X2[i:2,], nrow=1))
pred = predictions_scaled(fit_vecc, matrix(X2[1,], nrow=1))
pred = predictions_scaled(fit_vecc, matrix(X2[1:2,], nrow=2))
predictions_scaled
pred = predictions_scaled(fit_vecc, matrix(X2[1:2,], nrow=2))
pred
preds <- predictions_scaled(fit_vecc, X2)
tic()
preds <- predictions_scaled(fit_vecc, X2)
toc_vecc2 <- toc()
pred = predictions_scaled(fit_vecc, matrix(X2[c(i,i),], nrow=2))
pred = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))
i2 <- min(i+1, 2)
pred = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))
tic()
for(i in 1:N2){
i2 <- min(i+1, 2)
pred = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))
}
toc_vecc2 <- toc()
for(i in 1:N2){
i2 <- i - 1
if(i == 1){
i2 <- 2
}
pred = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))
}
tic()
for(i in 1:N2){
i2 <- i - 1
if(i == 1){
i2 <- 2
}
pred = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))
}
toc_vecc2 <- toc()
i
69/i*N2
yht_vecc <- rep(NA, N2)
yht_vecc <- rep(NA, N2)
tic()
for(i in 1:N2){
i2 <- i - 1
if(i == 1){
i2 <- 2
}
yht_vecc = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))[1]
}
toc_vecc2 <- toc()
i
94/i*N2
rmspe(y2[1:i], yht_vecc[1:i])
yht_vecc
yht_vecc <- rep(NA, N2)
tic()
for(i in 1:N2){
i2 <- i - 1
if(i == 1){
i2 <- 2
}
yht_vecc[i] = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))[1]
}
toc_vecc2 <- toc()
i
128/i*N2
rmspe(y2[1:i], yht_vecc[1:i])
yht_vecc
predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))[1]
plot(y2, yht_vecc)
which(is.na(yht_vecc))
i
rmspe(y2[1:i], yht_vecc[1:i])
rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])
rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])*60
plot(y2, yht_slap[,1])
plot(y2, yht_slap[,6])
plot(y2, yht_slap[,6])
plot(y2, yht_slap[,7])
plot(y2, yht_bass)
library(tictoc)
library(quack)
library(lhs)
library(GPvecchia)
source("R/piston.R")
source('https://raw.githubusercontent.com/katzfuss-group/scaledVecchia/master/vecchia_scaled.R')
# Generate data
set.seed(111)
N <- 40000
X <- quack::smartLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
# Get data for prediction
N2 <- 10000
X2 <- quack::smartLHS(N2, 7)
y2 <- apply(X2, 1, piston, scale01=TRUE)
# Fit scaled Vecchia GP (Katzfuss et al., 2020)
tic()
fit_vecc <- fit_scaled(y, X)
toc_vecc <- toc()
tic()
preds <- predictions_scaled(fit_vecc, X2)
toc_vecc2 <- toc()
yht_vecc <- rep(NA, N2)
tic()
for(i in 1:N2){
i2 <- i - 1
if(i == 1){
i2 <- 2
}
yht_vecc[i] = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2))[1]
}
toc_vecc2 <- toc()
rmspe <- rmspe(y2, yht_vec)
i
rmspe <- rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])
rmspe
rmspe*609
rmspe*60
i
predictions_scaled
preds <- predictions_scaled(fit_vecc, X2[1:10], predvar=TRUE)
preds <- predictions_scaled(fit_vecc, X2[1:10], predvar=TRUE, joint=FALSE)
preds <- predictions_scaled(fit_vecc, locs_pred = X2[1:10], predvar=TRUE, joint=FALSE)
?predictions_scaled
i
i2
matrix(X2[c(i, i2),]
matrix(X2[c(i, i2),], nrow=2)
matrix(X2[c(i, i2),], nrow=2)
nrow(matrix(X2[c(i, i2),], nrow=2))
preds <- predictions_scaled(fit_vecc, locs_pred = X2[1:10,], predvar=TRUE, joint=FALSE)
preds
library(tictoc)
library(quack)
library(lhs)
library(GPvecchia)
source("R/piston.R")
source('https://raw.githubusercontent.com/katzfuss-group/scaledVecchia/master/vecchia_scaled.R')
# Generate data
set.seed(111)
N <- 40000
X <- quack::smartLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
# Get data for prediction
N2 <- 10000
X2 <- quack::smartLHS(N2, 7)
y2 <- apply(X2, 1, piston, scale01=TRUE)
# Fit scaled Vecchia GP (Katzfuss et al., 2020)
tic()
fit_vecc <- fit_scaled(y, X)
toc_vecc <- toc()
yht_vecc <- rep(NA, N2)
tic()
for(i in 1:N2){
i2 <- i - 1
if(i == 1){
i2 <- 2
}
pred = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2), joint=FALSE, predvar=TRUE)
yht_vecc[i] <- pred$mean[1]
cov_vecc[i] <- (pred$mean[1] - 1.96*sqrt(pred$vars[1]) < y2[i]) & (pred$mean[1] + 1.96*sqrt(pred$var[1]) > y2[i])
}
toc_vecc2 <- toc()
rmspe <- rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])
library(tictoc)
library(quack)
library(lhs)
library(GPvecchia)
source("R/piston.R")
source('https://raw.githubusercontent.com/katzfuss-group/scaledVecchia/master/vecchia_scaled.R')
# Generate data
set.seed(111)
N <- 40000
X <- quack::smartLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
# Get data for prediction
N2 <- 10000
X2 <- quack::smartLHS(N2, 7)
y2 <- apply(X2, 1, piston, scale01=TRUE)
# Fit scaled Vecchia GP (Katzfuss et al., 2020)
tic()
fit_vecc <- cov_vecc <-  fit_scaled(y, X)
toc_vecc <- toc()
yht_vecc <- rep(NA, N2)
tic()
for(i in 1:N2){
i2 <- i - 1
if(i == 1){
i2 <- 2
}
pred = predictions_scaled(fit_vecc, matrix(X2[c(i, i2),], nrow=2), joint=FALSE, predvar=TRUE)
yht_vecc[i] <- pred$mean[1]
cov_vecc[i] <- (pred$mean[1] - 1.96*sqrt(pred$vars[1]) < y2[i]) & (pred$mean[1] + 1.96*sqrt(pred$var[1]) > y2[i])
}
toc_vecc2 <- toc()
rmspe <- rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])
rmspe
rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])
rmspe <- function(y, y2) sqrt(mean((y-y2)^2))
rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])
rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])*60
toc_vecc
mean(cov_vecc)
cov_vecc
mean(unlist(cov_vecc))
toc_vecc$toc - toc_vecc$tic
toc_vecc2$toc - toc_vecc2$tic
cat("Scaled Vecchia GP on piston function with N = ", N,
"\n   Train (s): ", toc_vecc$toc - toc_vecc$tic,
"\n   Pred (s): ", toc_vecc2$toc - toc_vecc2$tic,
"\n   RMSPE: ", tmp)
tmp <- rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])*60
yht_vec
tmp
cat("Scaled Vecchia GP on piston function with N = ", N,
"\n   Train (s): ", toc_vecc$toc - toc_vecc$tic,
"\n   Pred (s): ", toc_vecc2$toc - toc_vecc2$tic,
"\n   RMSPE: ", tmp*60)
tmp <- rmspe(y2[1:(i-1)], yht_vecc[1:(i-1)])*60
cat("Scaled Vecchia GP on piston function with N = ", N,
"\n   Train (s): ", toc_vecc$toc - toc_vecc$tic,
"\n   Pred (s): ", toc_vecc2$toc - toc_vecc2$tic,
"\n   RMSPE: ", tmp*60)
cat("Scaled Vecchia GP on piston function with N = ", N,
"\n   Train (s): ", toc_vecc$toc - toc_vecc$tic,
"\n   Pred (s): ", toc_vecc2$toc - toc_vecc2$tic,
"\n   RMSPE: ", tmp)
plot(y2, yht_vecc)
plot(y2, yht_vecc, xlim=c(.1, .2), ylim=c(.1, .2))
plot(y2 - yht_vecc)
plot(y2 - yht_bass)
plot(y2 - yht_ppr)
toc_ppr2$toc - toc_ppr$2
toc_ppr2$toc - toc_ppr2$tic
*20
(toc_ppr2$toc - toc_ppr2$tic)*20
load("Data/piston_sim_output_N40000.rda")
(toc_ppr2$toc - toc_ppr2$tic)*20
34697/60
34697/60/60
60*60
library(deepgp)
library(duqling)
library(lhs)
X <- maximinLHS(N, 7)
N <- 40
X <- maximinLHS(N, 7)
y <- apply(X, 1, piston, scale01=TRUE)
y
fit <- fit_two_layer(X, y)
z <- (y - mean(y))/sd(y)
fit <- fit_two_layer(X, z)
